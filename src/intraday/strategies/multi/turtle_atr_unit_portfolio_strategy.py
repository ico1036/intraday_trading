"""Auto-generated by trading-strategy-workflow from user prompt."""
from __future__ import annotations

import pandas as pd


class TurtleAtrUnitPortfolioStrategy:
    """User-requested strategy scaffold compatible with PortfolioBacktestRunner.

    Goal:
    터틀기반 전략을 만든다. 전체 트레이딩 자금의 1%를ATR 로 나 누것이 1 유닛이다. 동일 종목의 유닛 개수제한, 상관계수가 높은 종목의 유닛개수 제한을 건다. 청산조건도 노이즈보다 높은 수준의 ATR 조건을 건다. 진입조건도 다양하게 테스트 한다. 롱숏 가능하고 레버리지도 가능
    """

    def __init__(self, symbols: list[str], lookback_minutes: int = 60, top_n: int = 1, bottom_n: int = 1, **kwargs):
        self.symbols = symbols
        self.lookback_minutes = max(10, int(lookback_minutes))
        self.top_n = max(1, int(top_n))
        self.bottom_n = max(0, int(bottom_n))
        self.unit_risk = float(kwargs.get("n_unit", 0.01) or 0.01)
        self.max_units_per_symbol = int(kwargs.get("max_open_positions", 2) or 2)
        self.stop_atr = float(kwargs.get("stop_atr", 2.0) or 2.0)
        self.trail_atr = float(kwargs.get("trail_atr", 1.5) or 1.5)

    def calculate_rankings(self, price_data: dict[str, pd.Series]) -> dict[str, list[str]]:
        vals = []
        for s in self.symbols:
            series = price_data.get(s)
            if series is None or len(series) < 2:
                continue
            a = float(series.iloc[0])
            b = float(series.iloc[-1])
            if a == 0:
                continue
            vals.append((s, (b - a) / a))
        vals.sort(key=lambda x: x[1])
        longs = [s for s, _ in vals[-self.top_n:]] if vals else []
        shorts = [s for s, _ in vals[:self.bottom_n]] if self.bottom_n > 0 else []
        shorts = [s for s in shorts if s not in longs]
        return {"long": longs, "short": shorts}

    def generate_signals(self, rankings: dict[str, list[str]], current_positions: dict[str, str]) -> dict[str, str]:
        signals = {}
        long_targets = set(rankings.get("long", []))
        short_targets = set(rankings.get("short", []))

        for s in long_targets:
            cur = current_positions.get(s)
            if cur is None:
                signals[s] = "LONG"
            elif cur == "SHORT":
                signals[s] = "CLOSE_AND_LONG"

        for s in short_targets:
            cur = current_positions.get(s)
            if cur is None:
                signals[s] = "SHORT"
            elif cur == "LONG":
                signals[s] = "CLOSE_AND_SHORT"

        for s, pos in current_positions.items():
            if s not in long_targets and s not in short_targets:
                signals[s] = "CLOSE"

        return signals
